### 1.z-index和层叠规则

  z-index只适用于已定位的元素：即拥有relative、absolute或者fixed的元素

  按从下往上的顺序：

    1.层叠上下文：background和border

    2.负的z-index

    3.block块状水平盒子

    4.float浮动盒子

    5.inline水平盒子

    6.z-index:auto或z-index:0 不依赖z-index的层叠上下文

    7.正的z-index


### 2.css选择器权重

  第一等级：代表 内联样式，如 style=""，权值为 1,0,0,0；

  第二等级：代表 ID选择器，如 #id="", 权值为 0,1,0,0；

  第三等级：calss | 伪类 | 属性 选择器等，如 .class | :hover,:link,:target | [type], 权值 0,0,1,0；

  第四等级：标签 | 伪元素 选择器等，如 p | ::after, ::before, ::fist-inline, ::selection, 权值 0,0,0,1；

　此外，通用选择器（*)，子选择器(>)， 相邻同胞选择器(+)等选择器不在4等级之内，所以它们的权值都为 0,0,0,0；

  权值计算 公式：权值 = 第一等级选择器\*个数，第二等级选择器\*个数，第三等级选择器\*个数，第四等级选择器\*个数；


### 3.浏览器渲染页面的过程

  1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。

  2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。

  3.DOM Tree + CSSOM --> 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。

  DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。

  4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。


### 4.中断ajax请求

  ajax.abort()


### 5.target、currentTarget的区别

  currentTarget当前所绑定事件的元素

  target当前被点击的元素  


### 6.说一下宏任务和微任务

  宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器setTimeout等等）。
  
  微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，Mutation observer，process.nextTick等等）。

  宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。

  - 在每个宏任务结束，或每个回调之后js执行栈为空时，清空微任务

  - 每个宏任务之间，浏览器渲染页面

  - 宏任务是一次执行一个，微任务是一次清空


### 7.什么是会话cookie,什么是持久cookie

  cookie是服务器返回的，指定了expire time（有效期）的是持久cookie,没有指定的是会话cookie


### 8.渲染优化

  1.禁止使用iframe（阻塞父文档onload事件）；
    *iframe会阻塞主页面的Onload事件；
    *搜索引擎的检索程序无法解读这种页面，不利于SEO;
    *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

    使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
    动态给iframe添加src属性值，这样可以绕开以上两个问题。

  2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）；
  3、使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）；
  4、对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU；
    小图标优势在于：
    1.减少HTTP请求；
    2.避免文件跨域；
    3.修改及时生效；

  5、页面头部的<style></style> 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）；
  6、页面头部<script</script> 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）；
  7、页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)；
    
  8、网页Gzip，CDN托管，data缓存 ，图片服务器；
  9、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
  10、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
  11、当需要设置的样式很多时设置className而不是直接操作style。
  12、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
  13、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
  14、图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

  15、避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
       对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。
       向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，
       能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，
       本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。
       减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），
       减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。


### 9.css可继承的属性和不可继承的属性

  可继承的属性：font-size、font-family、line-height、color
  不可继承的属性：margin、padding、display、border（多半是跟盒模型有关的）


### 10.js的基本数据类型

  number、string、boolean、null、undefiend、object、symbol